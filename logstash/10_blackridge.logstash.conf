input {
  # Listen on UDP/514 for syslog messages.
  udp {
    type => "syslog"
    port => "${ESLOG_SYSLOG_PORT:514}"
  }
    
  # Listen on TCP/514 for syslog messages.
  tcp {
    type => "syslog"
    port => "${ESLOG_SYSLOG_PORT:514}"
  }

  file {
    path => "${ESLOG_BASE}/logs/dev.syslog"
    sincedb_path => "/dev/null"
    start_position => "beginning"
    ignore_older => 0
  }
}

filter {
  # Syslog messages can come in various basic formats. Here we check for common patterns and extract the basic fields as well as the logged message.
  grok {
    match => {
      "message" => "(?:<%{INT:syslog_pri}>\s*)?(?:%{SYSLOGTIMESTAMP:[@metadata][syslog_timestamp]}|%{TIMESTAMP_ISO8601:[@metadata][syslog_timestamp]})\s+(?:%{SYSLOGFACILITY}\s+)?%{IPORHOST:logging_host}\s+%{PROG:logging_process}(?:\[%{INT:logging_pid}\])?:\s+%{GREEDYDATA:logged_message}"
    }
  }
  if "_grokparsefailure" in [tags] {
    # Drop message if it didn't match any expected syslog message format.
    drop { }
  } else {
    syslog_pri { }

    # Set the date of the record to the timestamp from the syslog message.
    date {
      locale => "en"
      match => [ "[@metadata][syslog_timestamp]", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss", "MMM dd YYYY HH:mm:ss", "MMM  d YYYY HH:mm:ss", "ISO8601" ]
      timezone => "${ESLOG_SYSLOG_TZ:UTC}"
    }

    # Check if the message looks like a BlackRidge BMF message.
    grok {
      patterns_dir => [ "${ESLOG_GROK_PATTERNS_DIR:/etc/logstash/patterns}" ]
      match => { "logged_message" => "%{BMF_MSG}" }
      add_tag => [ "blackridge" ]
    }
    if "_grokparsefailure" in [tags] {
      # Drop messages that didn't match the BMF format.
      drop { }
    } else {
      # Parse the key-value pairs from the BMF payload, adding them as fields to the event.
      kv {
        source => "[@metadata][bmf_payload]"
        trim_key => "\""
        trim_value => "\""
      }

      # Check if source IP address is private.
      if [src] {
        cidr {
          address => [ "%{src}" ]
          network => [ "10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7", "127.0.0.0/8", "::1/128", "169.254.0.0/16", "fe80::/10","224.0.0.0/4", "ff00::/8","255.255.255.255/32" ]
          add_field => { "src_locality" => "private" }
        }
        # Check to see if src_locality exists. If it doesn't the src didn't match a private address space and locality must be public.
        if ![src_locality] {
          mutate {
            add_field => { "src_locality" => "public" }
          }
          geoip {
            source => "src"
            database => "${ESLOG_GEOIP_DBS_DIR:/etc/logstash/geoipdbs}/GeoLite2-City.mmdb"
            target => "geoip"
          }
          geoip {
            source => "src"
            database => "${ESLOG_GEOIP_DBS_DIR:/etc/logstash/geoipdbs}/GeoLite2-ASN.mmdb"
            target => "geoip"
          }
        }
      }

      if [destPort] {
        translate {
          dictionary_path => "${ESLOG_DICTIONARY_PATH:/etc/logstash/dictionaries}/iana_service_names_tcp.yml"
          field => "destPort"
          destination => "service"
          fallback => "__UNKNOWN"
        }
        # Check to see if the service field exists. If it doesn't then the service munber wasn't found in the translation table, so we will assign the service number to the service field.
        if [service] == "__UNKNOWN" {
          mutate {
            replace => { "service" => "%{[destPort]}" }
          }
        } else {
          mutate {
            replace => { "service" => "%{[service]} (%{[destPort]})" }
          }
        }
      }
    }
  }
}

output {
  #stdout {
  #  codec => rubydebug {
  #    metadata => true
  #  }
  #}

  if "blackridge" in [tags] {
    elasticsearch {
      hosts => [ "${ESLOG_ELASTICSEARCH_HOSTS:127.0.0.1:9200}" ]
      user => "${ESLOG_ELASTICSEARCH_USER}"
      password => "${ESLOG_ELASTICSEARCH_PASSWORD}"
      index => "blackridge-%{+YYYY.MM.dd}"
    }
  }
}
